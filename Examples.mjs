import runtime from "./Runtime.mjs";
import MutMap from "./MutMap.mjs";
import Predef from "./Predef.mjs";
let Examples1;
(class Examples {
  static {
    Examples1 = Examples;
    let tmp, tmp1, tmp2, tmp3, tmp4, tmp5, tmp6, tmp7, tmp8, tmp9, tmp10, tmp11, tmp12, tmp13, tmp14, tmp15, tmp16, tmp17, tmp18;
    this.examples = MutMap.empty;
    tmp = MutMap.insert("ExampleInResponse.mls", {
    "name": "Example in Response", "source": "\n// * This file contains examples in the author response. A few typos therein are corrected.\n\n\n// Some utility functions:\n\nfun wield: [R] -> (Region[out R]) ->{R} ()\nfun freeze: [R, E extends ~R, T] -> (Region[out R], () ->{~R & E} T) ->{R | E} T\n// ^ Fixed a typo in the author response (`{~R | E}` should have been `{~R & E}`)\n\nfun (;) seq(_, res) = res\nfun rand: () -> Bool\nfun print: Any -> ()\n\n\n// ### Example 1\n\n\n// Passing the same region for both arguments fundamentally does not work approaches like Rust and Capability Calculus.\nfun foo1(r1, r2) =\n  freeze(r1, () => print(\"ok\"))\n  wield(r2)\n\n// InvalML allows r1 and r2 to alias as long as \u2039body\u203A does not use r2; for instance:\nregion r in\n  foo1(r, r)\n\n// Capability Calculus and related systems would require r2 to be distinct from r1.\n\n// Note \u2013 this also works:\nregion r in\n  region s in\n    foo1(r, s)\n\n// Here is a slightly less trivial examples that still type checks seamlessly in InvalML:\nregion r0 in\n  \n  fun foo1(r1, r2) =\n    freeze(r1, () => wield(r0))\n    wield(r2)\n  \n  region r in\n    foo1(r, r)\n  \n  region r in\n    region s in\n      foo1(r, s)\n\n\n// On the other hand, given\nfun foo2(r1, r2) =\n  freeze(r1, () => wield(r2))\n  wield(r2)\n\n// we rightfully reject\n// region r in\n//   foo2(r, r)\n\n// but still accept\nregion r in\n  region s in\n    foo2(r, s)\n\n\n// ### Example 2\n\n\nfun foo3: [outer, R extends outer] -> Region[out R] ->{outer} ()\nfun foo3(r1) =\n  region r2 in\n    freeze(r2, () =>\n      wield(r1)\n    )\n// ^ Fixed typos in the author response (it used the paper's syntax instead of the implementation's syntax)\n\n// In fact, this formally equivalent signature also works:\nfun foo3': [outer] -> Region[out outer] ->{outer} ()\nfun foo3'(r1) = foo3(r1)\n\n\n// ### Example 3\n\n\nfun foo4(r1, r2, f) =\n  let exec = freeze(r1, () => freeze(r2, () => f(r1, r2)))\n  let r = exec()\n  !r + 1\n\nregion r in\n  region s in\n    foo4(r, s, (x, y) =>\n      if rand() then print(\"Chose x\"); () => x.ref 0\n                else print(\"Chose y\"); () => y.ref 1)\n\n\n// ### Example 4\n\n\nfun foo5(f) =\n  region r in\n    freeze(r, () => f(32))\n\n\nfun freeze2: [R, E extends ~R, T] -> (Region[out R], () ->{~R & E} T) ->{R | E} T\n\nfun foo6(f) =\n  region r in\n    freeze(r, () => f(32))\n\nfoo6\n"
    });
    tmp1 = Predef.pipeInto(Examples.examples, tmp);
    tmp2 = MutMap.insert("ExampleInThePaper.mls", {
    "name": "Example in the Paper", "source": "\n// * This file contains examples in the paper\n\nclass ArrayList[A, R]\nclass List[A]\nclass Iter[T, R]\n\nfun mkArrayList : [R, T] -> (Region[out R]) ->{R} ArrayList[T, R]\nfun add : [R, T] -> (ArrayList[T, R], T) ->{R} ()\nfun clear : [R, T] -> ArrayList[T, R] ->{R} ()\nfun foreach : [E, R, T] -> (Iter[T, R], T ->{E} ()) -> {R | E} ()\nfun iter : [Res, R, E extends ~R, T] -> (ArrayList[T, R], [I] -> Iter[T, I] ->{I | E} Res) ->{E | R} Res\nfun map: [T, S, E] -> (List[out T], T ->{E} S) ->{E} List[out S]\n\nfun println: Any -> ()\nfun (;) seq(_, res) = res\n\nregion r in // This is used to delimit the scope of mutation\n  let xs = mkArrayList(r) // Creates a new mutable list in r egion r\n  add(xs, \"1\"); add(xs, \"2\"); add(xs, \"3\");\n  iter(xs, it => foreach(it , e => println(e)))\n\n// region r in // This is used to delimit the scope of mutation\n//   let xs = mkArrayList(r) // Creates a new mutable list in r egion r\n//   add(xs, \"1\"); add(xs, \"2\"); add(xs, \"3\");\n//   iter(xs, it => foreach(it , e => println (e); clear (xs)))\n\nfun mapi: [A, B, E] -> (List[out A], (Int, A) ->{E} B) ->{E} List[out B]\nfun mapi(xs, f) =\n  region r in\n    let index = r.ref 0 in map(xs, x => let res = f(!index, x) in index := !index + 1; res)\n\n\nfun f: [R1, R2 extends ~R1] -> (Region[out R1], Region[out R2]) ->{R1 | R2} Int\n\n\n// region r1 in\n//   let g = (r => region r2 in f(r, r2)) in (region r3 in g(r3))\n\n\nregion r1 in\n  fun g: [outer, R extends outer] -> Region[out R] ->{R} Int\n  fun g(r) = region r2 in f(r, r2)\n  region r3 in g(r3)\n\n\nregion r in\n  let a1 = mkArrayList(r) in add(a1, 12); add(a1, 34);\n  iter of a1, it1 =>\n    region s in\n      let a2 = mkArrayList(s)\n      foreach of it1, v1 => add(a2 , v1)\n      iter of a2, it2 => foreach of it2 , v2 => println(v2)\n      clear(a2)\n\n\n// region r in\n//   let a = mkArrayList(r) in add(a, 12); add(a, 34);\n//   iter of a, it =>\n//     foreach of it, v => println(v); clear(a)\n"
    });
    tmp3 = Predef.pipeInto(Examples.examples, tmp2);
    tmp4 = MutMap.insert("MergeSort.mls", {
    "name": "Merge Sort", "source": "\n// * This file includes the implementation for merge sorting,\n// * executed sequentially or in parallel.\n// * Adapted from https://doi.org/10.5281/zenodo.8425443\n\n\n// *** infrastructures\n\n\ndeclare class Array[T, R]\n\n\nclass Pair[T, S] with\n  constructor\n    Pr(fst: T, snd: S)\n\n\nfun\n  mkArray: [T, R] -> Region[out R] ->{R} Array[T, out R]\n  push: [T, R] -> (Array[in T, out R], T) ->{R} ()\n  unshift: [T, R] -> (Array[in T, out R], T) ->{R} ()\n  map: [T, S, R, E extends ~R] -> (Array[out T, out R], T ->{E} S) ->{E | R} Array[S, out R]\n  foreach: [T, R, E extends ~R] -> (Array[out T, out R], T ->{E} ()) ->{E | R} ()\n  len: [R] -> Array[in Nothing out Any, out R] ->{R} Int\n  at: [T, R] -> (Array[out T, out R], Int) ->{R} T\n  slice: [T, R] -> (Array[out T, out R], Int) ->{R} Array[out T, out R]\n  concat: [T, R1, R2, R3] -> (Region[out R3], Array[in T, out R1], Array[out T, out R2]) ->{R1 | R2 | R3} Array[T, out R3]\n\n\n// Matching on js array is not supported yet.\n// This helper function is equivalent to `if xs is Cons(x, xs) then fh(x, xs) else fn(xs)`\nfun matchOne(xs, fn, fh) =\n  if len(xs) is 0 then fn(xs)\n  else fh(at(xs, 0), slice(xs, 1))\n\n// Matching on js array is not supported yet.\n// This helper function is equivalent to\n// `if xs is Cons(x, Cons(y, ys)) then f2(x, y, ys) else if xs is Cons(x, xs) then f1(x, xs) else fn(xs)`\n// fun matchTwo: [T, R, E1, E2, E3, S] -> (Array[out T, out R], Array[out T, out R] ->{E1} S, T ->{E2} S, (T, T, Array[out T, out R]) ->{E3} S) ->{E1 | E2 | E3 | R} S\nfun matchTwo(xs, fn, f1, f2) =\n  if len(xs) is 0 then fn(xs)\n  else if len(xs) is 1 then f1(at(xs, 0))\n  else f2(at(xs, 0), at(xs, 1), slice(xs, 2))\n\nfun (;) seq(_, res) = res\n\nfun println: Any -> ()\nfun forkJoin: [T, S, P, E1, E2 extends ~E1, E3] ->\n  (() ->{E1} T, () ->{E2} S, (T, S) ->{E3} P) ->{E1 | E2 | E3} P\n\n\n// *** pmsort implementation\n\n// Split the given array into two sub-arrays.\n// Region r1 and r2 indicate where the two sub-arrays should be stored.\nfun split(xs, r1, r2) =\n  fun rs(xs, ys, zs) =\n    matchTwo of xs, _ => Pr(ys, zs), x => push(ys, x); Pr(ys, zs), (x1, x2, r) => push(ys, x1); push(zs, x2); rs(r, ys, zs)\n  rs(xs, mkArray(r1), mkArray(r2))\n\n\n// Merge arr1 and arr2. The result is stored in region r.\n// fun merge: [T, R1, R2, R] -> (Array[out T, out R1], Array[out T, out R2], Region[R]) ->{R1 | R2 | R} Array[T, out R]\nfun merge(arr1, arr2, r) =\n  fun recm(xs, ys, acc) =\n    matchOne of xs, _ => concat(r, acc, ys), (x, rx) =>\n      matchOne of ys, _ => concat(r, acc, xs), (y, ry) =>\n        if x < y then push(acc, x); recm(rx, ys, acc)\n        else push(acc, y); recm(xs, ry, acc)\n  recm(arr1, arr2, mkArray(r))\n\n\n// Merge sort in single thread.\nfun smsort(xs, r) =\n  matchTwo of xs, _ => mkArray(r), x => let res = mkArray(r) in push(res, x); res, (_, _, _) =>\n    let p = split(xs, r, r) in\n      if p is Pr(fst, snd) then merge(smsort(fst, r), smsort(snd, r), r)\n\n\n// Wrong version! Sub-arrays cannot be stored in the same region!\n// fun pmsort: [R1, R2] -> (Array[out Int, out R1], Region[R2]) ->{R1 | R2} Array[Int, out R2]\n// fun pmsort(xs, r) =\n//   matchTwo of xs, _ => mkArray(r), x => let res = mkArray(r) in push(res, x); res, (_, _, _) =>\n//     let p = split(xs, r, r) in\n//       if p is Pr(fst, snd) then\n//         forkJoin(_ => pmsort(fst, r), pmsort(snd, r), (r1, r2) => merge(r1, r2, r))\n\n\n// Merge sort in parallel.\nfun pmsort: [R1, R2] -> (Array[out Int, out R1], Region[out R2]) ->{R1 | R2} Array[Int, out R2]\nfun pmsort(xs, r) =\n  matchTwo of xs, _ => mkArray(r), x => let res = mkArray(r) in push(res, x); res, (_, _, _) =>\n    region r1 in\n      region r2 in\n        let p = split(xs, r1, r2) in\n          if p is Pr(fst, snd) then\n            forkJoin(() => pmsort(fst, r1), () => pmsort(snd, r2), (rx, ry) => merge(rx, ry, r))\n\n\n// *** simple tests\n\nregion r in\n  let arr = mkArray(r)\n  push(arr, 10)\n  push(arr, 23)\n  push(arr, 13)\n  push(arr, 4)\n  smsort(arr, r)\n\nregion r in\n  let arr = mkArray(r)\n  push(arr, 10)\n  push(arr, 23)\n  push(arr, 13)\n  push(arr, 4)\n  pmsort(arr, r)\n"
    });
    tmp5 = Predef.pipeInto(Examples.examples, tmp4);
    tmp6 = MutMap.insert("SimpleConstraintSolver.mls", {
    "name": "Simple Constraint Solver", "source": "\n// * In this file, we implement a simple constraint solver, originally presented in https://doi.org/10.1145/3410225\n\n// *** infrastructures\n\nfun not(b) = if b then false else true\nfun (;) seq(_, res) = res\nfun id(x) = x\n\nfun println: Any -> ()\nfun (~) concat: (Str, Str) -> Str\nfun toString: Any -> Str\nfun (===) streq: (Str, Str) -> Bool\nfun error() = error()\n\nclass PairOf[out A, out B] with\n  constructor\n    Pair(fst: A, snd: B)\n\nclass Option[out A] with\n  constructor\n    None()\n    Some(value: A)\n\nclass List[out A] with\n  constructor\n    Nil()\n    Cons(head: A, tail: List[A])\n\nfun fold(x, xs, f) = if xs is\n  Nil() then x\n  Cons(y, ys) then fold(f(x, y), ys, f)\n\nfun map(xs, f) = if xs is\n  Nil() then Nil()\n  Cons(x, xs) then Cons(f(x), map(xs, f))\n\nfun each(xs, f) = if xs is\n  Nil() then ()\n  Cons(x, xs) then f(x); each(xs, f)\n\nfun find(xs, f) = if xs is\n  Nil() then None()\n  Cons(x, xs) then\n    if f(x) then Some(x)\n    else find(xs, f)\n\nclass ArrayList[T, out R]\nclass Iter[T, out R]\nclass HashMap[K, V, out R]\nclass MapIter[T, out R]\n\n// fun empty:   [A, R] -> Region[R] ->{R} ArrayList[out A, out R]  // TODO investigate: why does this break things?\nfun empty: [A, R] -> Region[out R] ->{R} ArrayList[A, out R]\nfun clear: [A, R] -> (ArrayList[A, out R]) ->{R} ()\nfun push: [A, R] -> (ArrayList[A, R], A) ->{R} ()\nfun len: [A, R] -> (ArrayList[A, R]) ->{R} Int\nfun iter: [Res, R, E extends ~R, T] -> (ArrayList[T, R], [S] -> Iter[T, S] ->{S | E} Res) ->{E | R} Res\nfun next: [T, S] -> Iter[T, S] ->{S} Option[T]\nfun whileDo: [R] -> (() ->{R} Bool) ->{R} ()\nfun foreach: [E, R, T] -> (Iter[T, R], T ->{E} ()) ->{R | E} ()\nfun max(x, y) = if x < y then y else x\n\nfun mkHashMap: [R, K, V] -> (Region[out R], K -> Str) ->{R} HashMap[K, V, R]\nfun getOrUpdate: [R, K, V, E] -> (HashMap[K, V, R], K, () ->{E} V) ->{E | R} V\nfun hasOrUpdate: [R, K, V, E] -> (HashMap[K, V, R], K, () ->{E} V) ->{E | R} ()\nfun iterMap: [Res, R, E extends ~R, K, V] -> (HashMap[K, V, R], [S] -> MapIter[V, S] ->{S | E} Res) ->{E | R} Res\nfun nextVal: [T, S] -> MapIter[T, S] ->{S} Option[T]\nfun hasKey: [K, V, R] -> (HashMap[K, V, R], K) ->{R} Bool\nfun add: [K, V, R] -> (HashMap[K, V, R], K, V) ->{R} ()\nfun values: [E, R, T] -> (MapIter[T, R], T ->{E} ()) ->{R | E} ()\n\n// *** simple constraint solver\n\n\n// Unif contains a type variable's id, lower bounds, and upper bounds.\nclass Type[out R] with\n  constructor\n    IntType()\n    FunctionType(lhs: Type[R], rhs: Type[R])\n    RecordType(fields: List[PairOf[Str, Type[R]]])\n    TypeVariable(id: Str, level: Int, lowerBounds: ArrayList[Type[R], R], upperBounds: ArrayList[Type[R], R])\n    \n\nfun isSimpl(ty) = if ty is\n  FunctionType(_, _) then false\n  else true\n\n\nfun ty2Str(ty) = if ty is\n  IntType() then \"Int\"\n  FunctionType(lhs, rhs) then\n    let ls = if isSimpl(lhs) then ty2Str(lhs) else \"(\" ~ ty2Str(lhs) ~ \")\"\n    ls ~ \" -> \" ~ ty2Str(rhs)\n  RecordType(fields) then \"{ \" ~ fold(\"\", fields, (s, p) => if p is Pair(n, t) then s ~ n ~ \": \" ~ ty2Str(t) ~ \", \") ~ \"}\"\n  TypeVariable(name, level, _, _) then name ~ \"_\" ~ toString(level)\n\n// fun levelOf: [R] -> Type[R] -> Int\nfun levelOf(ty) = if ty is\n  IntType() then 0\n  FunctionType(lhs, rhs) then max(levelOf(lhs), levelOf(rhs))\n  RecordType(fields) then fold(0, fields, (r, p) => if p is Pair(_, t) then max(r, levelOf(t)))\n  TypeVariable(_, level, _, _) then level\n\nfun report(lhs, rhs) =\n  println(\"Cannot constrain \" ~ ty2Str(lhs) ~ \" <: \" ~ ty2Str(rhs) ~ \"!\")\n\n\nfun extrude: [outer, R extends outer] -> (Type[R], Bool, Int, (Str, Int) ->{R} Type[R], HashMap[PairOf[Type[R], PairOf[Int, Bool]], Type[R], R]) ->{R} Type[R]\nfun extrude(ty, pol, lvl, freshVar, cache) = getOrUpdate of cache, Pair(ty, Pair(lvl, pol)), () =>\n  if levelOf(ty) <= lvl then ty\n  else if ty is\n    IntType() then ty\n    FunctionType(lhs, rhs) then\n      FunctionType(extrude(lhs, not(pol), lvl, freshVar, cache), extrude(rhs, pol, lvl, freshVar, cache))\n    RecordType(fields) then\n      RecordType(map(fields, p => if p is Pair(name, ty) then Pair(name, extrude(ty, pol, lvl, freshVar, cache))))\n    TypeVariable(name, level, lb, ub) then\n      let nc = freshVar(name ~ \"'\" ~ (if pol then \"+\" else \"-\"), lvl)\n      if pol then\n        push(ub, nc)\n        let nlb = if nc is\n          TypeVariable(_, _, lb, _) then lb\n          else error() // impossible\n        region r in\n          let nbd = empty(r)\n          iter of lb, it => foreach(it, b => push(nbd, b))\n          iter of nbd, it => foreach(it, b => push(nlb, extrude(b, pol, lvl, freshVar, cache)))\n      else\n        push(lb, nc)\n        let nub = if nc is\n          TypeVariable(_, _, _, ub) then ub\n          else error() // impossible\n        region r in\n          let nbd = empty(r)\n          iter of ub, it => foreach(it, b => push(nbd, b))\n          iter of nbd, it => foreach(it, b => push(nub, extrude(b, pol, lvl, freshVar, cache)))\n      nc\n\n// fun solve: [outer, R extends outer] -> (List[PairOf[Type[R], Type[R]]], (Str, Int) ->{R} Type[R], HashMap[PairOf[Type[R], Type[R]], Any, R], () ->{R} HashMap[PairOf[Type[R], PairOf[Int, Bool]], Type[R], R]) ->{R} ()\nfun solve(constraints, freshVar, cache, genExtrCache) = if constraints is\n  Nil() then ()\n  Cons(c, cs) then if c is\n    Pair(lhs, rhs) then hasOrUpdate of cache, c, () =>\n      if lhs is\n        IntType() then if rhs is\n          IntType() then solve(cs, freshVar, cache, genExtrCache)\n          TypeVariable(name, level, lb, ub) then\n            push(lb, lhs)\n            region r in\n              let ncs = r.ref cs\n              iter(ub, it => foreach(it, b => ncs := Cons(Pair(lhs, b), !ncs); ()))\n              solve(!ncs, freshVar, cache, genExtrCache)\n          else report(lhs, rhs)\n        FunctionType(arg, res) then if rhs is\n          FunctionType(arg', res') then\n            solve(Cons(Pair(arg', arg), Cons(Pair(res, res'), cs)), freshVar, cache, genExtrCache)\n          TypeVariable(name, level, lb, ub) then\n            if levelOf(lhs) <= level then\n              push(lb, lhs)\n              region r in\n                let ncs = r.ref cs\n                iter(ub, it => foreach(it, b => ncs := Cons(Pair(lhs, b), !ncs); ()))\n                solve(!ncs, freshVar, cache, genExtrCache)\n            else\n              let lhs' = extrude(lhs, true, level, freshVar, genExtrCache())\n              solve(Cons(Pair(lhs', rhs), cs), freshVar, cache, genExtrCache)\n          else report(lhs, rhs)\n        RecordType(flds) then if rhs is\n          RecordType(flds') then each(flds', p' =>\n            if p' is Pair(n', t') then\n              if find(flds, p => if p is Pair(n, t) then n === n') is\n                Some(p) then if p is Pair(n, t) then solve(Cons(Pair(t, t'), cs), freshVar, cache, genExtrCache)\n                None() then println(\"Missing field \" ~ n' ~ \" in \" ~ ty2Str(lhs))\n            )\n          TypeVariable(name, level, lb, ub) then\n            if levelOf(lhs) <= level then\n              push(lb, lhs)\n              region r in\n                let ncs = r.ref cs\n                iter(ub, it => foreach(it, b => ncs := Cons(Pair(lhs, b), !ncs); ()))\n                solve(!ncs, freshVar, cache, genExtrCache)\n            else\n              let lhs' = extrude(lhs, true, level, freshVar, genExtrCache())\n              solve(Cons(Pair(lhs', rhs), cs), freshVar, cache, genExtrCache)\n          else report(lhs, rhs)\n        TypeVariable(name, level, lb, ub) then\n          if levelOf(rhs) <= level then\n            push(ub, rhs)\n            region r in\n              let ncs = r.ref cs\n              iter(lb, it => foreach(it, b => ncs := Cons(Pair(b, rhs), !ncs); ()))\n              solve(!ncs, freshVar, cache, genExtrCache)\n          else\n            let rhs' = extrude(rhs, false, level, freshVar, genExtrCache())\n            solve(Cons(Pair(lhs, rhs'), cs), freshVar, cache, genExtrCache)\n\n\nfun freshVar(r, ctx, name, lvl) =\n  if (not of hasKey(ctx, name)) then\n    add(ctx, name, 1)\n    TypeVariable(name, lvl, empty(r), empty(r))\n  else\n    region r2 in\n      let i = r2.ref 0\n      let res = r2.ref None()\n      whileDo of () =>\n        let nn = name ~ toString(!i)\n        if (not of hasKey(ctx, nn)) then\n          res := Some(TypeVariable(nn, lvl, empty(r), empty(r)))\n          add(ctx, nn, 1)\n          false\n        else\n          i := !i + 1\n          true\n      if !res is\n        Some(v) then v\n        else error()\n\n\nfun genHash(r) =\n  mkHashMap(r, p => if p is Pair(x, y) then ty2Str(x) ~ \" <: \" ~ ty2Str(y))\n\nfun genExtrHash(r) =\n  () => mkHashMap(r, t => if t is Pair(ty, p) then if p is Pair(lvl, pol) then ty2Str(ty) ~ (if pol then \"+_\" else \"-_\") ~ toString(lvl))\n\nfun printBounds(tv) = if tv is\n  TypeVariable(name, level, lb, ub) then\n    iter of lb, it =>\n      foreach of it, b => println(\"  \" ~ ty2Str(b) ~ \" <: \" ~ ty2Str(tv))\n    iter of ub, it =>\n      foreach of it, b => println(\"  \" ~ ty2Str(tv) ~ \" <: \" ~ ty2Str(b))\n  else ()\n\n// fun printRes: [outer, R extends outer] -> (Type[R], Type[R]) ->{R} ()\nfun printRes(lhs, rhs) =\n  println(ty2Str(lhs) ~ \" <: \" ~ ty2Str(rhs))\n  region r in\n    let tvs = mkHashMap(r, s => s)\n    // fun go: [outer, R extends outer, S extends outer] -> (Type[R], HashMap[Str, Type[R], S]) ->{R | S} ()\n    fun go(t, tvs) = if t is\n        IntType() then ()\n        FunctionType(lhs, rhs) then go(lhs, tvs); go(rhs, tvs)\n        RecordType(fields) then each(fields, p => if p is Pair(_, t) then go(t, tvs))\n        TypeVariable(name, level, lb, ub) then\n          getOrUpdate of tvs, name ~ toString(level), () =>\n            region r2 in\n              let tmp = empty(r2)\n              iter of lb, it => foreach(it, ty => push(tmp, ty))\n              iter of ub, it => foreach(it, ty => push(tmp, ty))\n            t\n          ()\n    go(lhs, tvs); go(rhs, tvs)\n    println(\"where: \")\n    iterMap of tvs, it =>\n      values of it, printBounds\n\n// *** error example\n\n// if we call the `solve` function during the iteration, the `solve` function\n// can only handle the cases where no allocation is required (i.e., no type variables)\n// fun TODO() = TODO()\n// fun wrongSolve(constraints, freshVar, cache, genExtrCache) = if constraints is\n//   Nil() then ()\n//   Cons(c, cs) then if c is\n//     Pair(lhs, rhs) then hasOrUpdate of cache, c, () =>\n//       if lhs is\n//         IntType() then TODO()\n//         FunctionType(arg, res) then TODO()\n//         RecordType(flds) then TODO()\n//         TypeVariable(name, level, lb, ub) then\n//           if levelOf(rhs) <= level then\n//             push(ub, rhs)\n//             iter(lb, it => foreach(it, b => solve(Cons(Pair(b, rhs), Nil()), freshVar, cache, genExtrCache)))\n//             solve(cs, freshVar, cache, genExtrCache)\n//           else\n//             let rhs' = extrude(rhs, false, level, freshVar, genExtrCache())\n//             solve(Cons(Pair(lhs, rhs'), cs), freshVar, cache, genExtrCache)\n\n\n// The error' version of `solve` function can only be used for constraints without type variables\n// wrongSolve(Cons(Pair(IntType, IntType), Nil()))\n\n// Calling the `wrongSolve` function to solve constraints involving type variables will lead to type errors\n// region r in\n//   let ctx = mkHashMap(r, s => s)\n//   let a = freshVar(r, ctx, \"a\", 1)\n//   let b = freshVar(r, ctx, \"a\", 1)\n//   let lhs = a\n//   let rhs = b\n//   wrongSolve(Cons(Pair(lhs, rhs), Nil()), (n, l) => freshVar(r, ctx, n, l), genHash(r), genExtrHash(r))\n//   printRes(lhs, rhs)\n\n// *** examples\n\nregion r in\n  let ctx = mkHashMap(r, s => s)\n  let lhs = FunctionType(IntType(), IntType())\n  let rhs = IntType()\n  solve(Cons(Pair(lhs, rhs), Nil()), (n, l) => freshVar(r, ctx, n, l), genHash(r), genExtrHash(r))\n\nregion r in\n  let ctx = mkHashMap(r, s => s)\n  let lhs = FunctionType(IntType(), IntType())\n  let a = freshVar(r, ctx, \"a\", 1)\n  let rhs = FunctionType(a, a)\n  solve(Cons(Pair(lhs, rhs), Nil()), (n, l) => freshVar(r, ctx, n, l), genHash(r), genExtrHash(r))\n  printRes(lhs, rhs)\n\n\nregion r in\n  let ctx = mkHashMap(r, s => s)\n  let lhs = RecordType(Cons(Pair(\"a\", IntType()), Cons(Pair(\"b\", FunctionType(IntType(), IntType())), Nil())))\n  let a = freshVar(r, ctx, \"a\", 1)\n  let b = freshVar(r, ctx, \"b\", 1)\n  let rhs = RecordType(Cons(Pair(\"a\", a), Cons(Pair(\"b\", b), Nil())))\n  solve(Cons(Pair(lhs, rhs), Nil()), (n, l) => freshVar(r, ctx, n, l), genHash(r), genExtrHash(r))\n  printRes(lhs, rhs)\n\n\nregion r in\n  let ctx = mkHashMap(r, s => s)\n  let a = freshVar(r, ctx, \"a\", 1)\n  let b = freshVar(r, ctx, \"b\", 1)\n  let lhs = a\n  let rhs = b\n  solve(Cons(Pair(lhs, rhs), Cons(Pair(rhs, lhs), Nil())), (n, l) => freshVar(r, ctx, n, l), genHash(r), genExtrHash(r))\n  printRes(lhs, rhs)\n  printRes(rhs, lhs)\n\n\nregion r in\n  let ctx = mkHashMap(r, s => s)\n  let lhs = RecordType(Cons(Pair(\"a\", IntType()), Cons(Pair(\"b\", FunctionType(IntType(), IntType())), Nil())))\n  let b = freshVar(r, ctx, \"b\", 1)\n  let rhs = RecordType(Cons(Pair(\"b\", b), Nil()))\n  solve(Cons(Pair(lhs, rhs), Nil()), (n, l) => freshVar(r, ctx, n, l), genHash(r), genExtrHash(r))\n  printRes(lhs, rhs)\n\n\nregion r in\n  let ctx = mkHashMap(r, s => s)\n  let a = freshVar(r, ctx, \"a\", 1)\n  let b = freshVar(r, ctx, \"b\", 1)\n  let lhs = FunctionType(IntType(), a)\n  let rhs = FunctionType(IntType(), b)\n  if a is\n    TypeVariable(_, _, _, ub) then push(ub, lhs)\n    else error() // impossible\n  if b is\n    TypeVariable(_, _, lb, _) then push(lb, rhs)\n    else error() // impossible\n  solve(Cons(Pair(a, b), Nil()), (n, l) => freshVar(r, ctx, n, l), genHash(r), genExtrHash(r))\n  printRes(a, b)\n\n\nregion r in\n  let ctx = mkHashMap(r, s => s)\n  let a = freshVar(r, ctx, \"a\", 1)\n  let lhs = a\n  let rhs = FunctionType(IntType(), IntType())\n  if a is\n    TypeVariable(_, _, lb, ub) then push(lb, IntType())\n    else error() // impossible\n  solve(Cons(Pair(lhs, rhs), Nil()), (n, l) => freshVar(r, ctx, n, l), genHash(r), genExtrHash(r))\n\n\nregion r in\n  let ctx = mkHashMap(r, s => s)\n  let a = freshVar(r, ctx, \"a\", 1)\n  let b = freshVar(r, ctx, \"b\", 2)\n  let lhs = FunctionType(IntType(), a)\n  let rhs = FunctionType(IntType(), b)\n  solve(Cons(Pair(lhs, rhs), Nil()), (n, l) => freshVar(r, ctx, n, l), genHash(r), genExtrHash(r))\n  printRes(lhs, rhs)\n\n\nregion r in\n  let ctx = mkHashMap(r, s => s)\n  let a = freshVar(r, ctx, \"a\", 1)\n  let b = freshVar(r, ctx, \"a\", 1)\n  let lhs = a\n  let rhs = b\n  solve(Cons(Pair(lhs, rhs), Nil()), (n, l) => freshVar(r, ctx, n, l), genHash(r), genExtrHash(r))\n  printRes(lhs, rhs)\n\n\nregion r in\n  let ctx = mkHashMap(r, s => s)\n  let a = freshVar(r, ctx, \"a\", 1)\n  let b = freshVar(r, ctx, \"b\", 2)\n  let lhs = a\n  let rhs = FunctionType(b, FunctionType(b, b))\n  solve(Cons(Pair(lhs, rhs), Nil()), (n, l) => freshVar(r, ctx, n, l), genHash(r), genExtrHash(r))\n  printRes(lhs, rhs)\n"
    });
    tmp7 = Predef.pipeInto(Examples.examples, tmp6);
    tmp8 = MutMap.insert("GUI.mls", {
    "name": "GUI", "source": "\n// * This file includes the type checking implementation for the GUI example\n// * adapted from https://doi.org/10.5281/zenodo.7990289\n\nclass Block\nclass IO\nclass Label\nclass Button\n\n// * So far, our system does not support impure programs.\n// * We explicitly insert this handle function at **the top level** to allow primitive effects like IO and Block\nfun doPrimitiveEffects: [Res, E] -> (() ->{E | IO | Block} Res) ->{E} Res\n\nfun sleep: (Int) ->{Block} ()\n\nfun mkLabel: (Str) ->{IO} Label\nfun mkButton: (Str) ->{IO} Button\n\nfun setText: (Str, Label) ->{IO} ()\n\n// The callback function should not block the execution\n// so `E` has an upper bound `~Block`\nfun addActionListener: [T, E extends ~Block] -> (() ->{E} (), Button) ->{E | T} ()\n\n\n\n// examples\n\ndoPrimitiveEffects of () =>\n  sleep(42)\n\ndoPrimitiveEffects of () =>\n  mkLabel(\"Hello, World!\")\n\ndoPrimitiveEffects of () =>\n  let label = mkLabel(\"Hello, World!\")\n  sleep(42)\n  setText(\"Goodbye, World!\", label)\n\n// ok! `setText` will not block the execution\ndoPrimitiveEffects of () =>\n  let label = mkLabel(\"label\")\n  let button = mkButton(\"button\")\n  addActionListener(() => setText(\"clicked!\", label), button)\n\n\n\n// error! `sleep` will block the execution and the compiler reject the following program\n// doPrimitiveEffects of () =>\n//   let label = mkLabel(\"label\")\n//   let button = mkButton(\"button\")\n//   addActionListener(() => sleep(1), button)\n"
    });
    tmp9 = Predef.pipeInto(Examples.examples, tmp8);
    tmp10 = MutMap.insert("Interpreter.mls", {
    "name": "Interpreter", "source": "\n// * This file includes the implementation for an interpreter and a compiler for a small toy programming language.\n// * Adapted from https://doi.org/10.5281/zenodo.7990289\n\n\nclass List[T] with\n  constructor\n    Nil\n    Cons(x: T, xs: List[out T])\n\n\nfun concat: [T] -> (List[out T], List[out T]) -> List[out T]\nfun (;) seq(_, res) = res\nfun error: Nothing\n\n\n// * Arithmetical Expression\nclass AExp with\n  constructor\n    Cst(v: Int)\n    Plus(lhs: AExp, rhs: AExp)\n    Minus(lhs: AExp, rhs: AExp)\n    Times(lhs: AExp, rhs: AExp)\n    IfThenElse(cond: BExp, cons: AExp, alts: AExp)\n\n\n// * Boolean Expression\nclass BExp with\n  constructor\n    True\n    False\n    Not(v: BExp)\n    Conj(lhs: BExp, rhs: BExp)\n    Disj(lhs: BExp, rhs: BExp)\n    Eq(lhs: AExp, rhs: AExp)\n    Neq(lhs: AExp, rhs: AExp)\n\n\n// * Evaliation functions\n\nfun evalBExp: BExp -> Bool\n\nfun evalAExp(e) = if e is\n  Cst(v) then v\n  Plus(e1, e2) then evalAExp(e1) + evalAExp(e2)\n  Minus(e1, e2) then evalAExp(e1) - evalAExp(e2)\n  Times(e1, e2) then evalAExp(e1) * evalAExp(e2)\n  IfThenElse(cond, e1, e2) then\n    if evalBExp(cond) then evalAExp(e1) else evalAExp(e2)\n\n\nfun evalBExp(e) = if e is\n  True then true\n  False then false\n  Not(e) then evalBExp(e) is false\n  Conj(e1, e2) then evalBExp(e1) && evalBExp(e2)\n  Disj(e1, e2) then evalBExp(e1) || evalBExp(e2)\n  Eq(e1, e2) then evalAExp(e1) == evalAExp(e2)\n  Neq(e1, e2) then evalAExp(e1) != evalAExp(e2)\n\n\n// * Examples\n\nevalAExp(Cst(42))\nevalAExp(Plus(Cst(42), Cst(21)))\nevalAExp(Minus(Cst(42), Cst(21)))\nevalAExp(IfThenElse(True, Cst(1), Cst(2)))\nevalAExp(IfThenElse(Neq(Cst(1), Cst(2)), Cst(42), Cst(21)))\n\nevalBExp(True)\nevalBExp(Not(True))\nevalBExp(Conj(True, False))\nevalBExp(Disj(True, False))\nevalBExp(Neq(Cst(1), Cst(2)))\n\n\n// * Instruction\nclass Inst with\n  constructor\n    Push(v: Int)\n    Add\n    Sub\n    Mul\n    Neg\n    And\n    Or\n    Cmp\n    Branch(cons: List[out Inst], alts: List[out Inst])\n\n\n// * Compilation functions\n\nfun compileBExp: BExp -> List[out Inst]\n\nfun compileAExp(e) = if e is\n  Cst(v) then Cons(Push(v), Nil)\n  Plus(e1, e2) then\n    let is1 = compileAExp(e1) in\n      let is2 = compileAExp(e2) in\n        concat(concat(is2, is1), Cons(Add, Nil))\n  Minus(e1, e2) then\n    let is1 = compileAExp(e1) in\n      let is2 = compileAExp(e2) in\n        concat(concat(is2, is1), Cons(Sub, Nil))\n  Times(e1, e2) then\n    let is1 = compileAExp(e1) in\n      let is2 = compileAExp(e2) in\n        concat(concat(is2, is1), Cons(Mul, Nil))\n  IfThenElse(e1, e2, e3) then\n    let is1 = compileBExp(e1) in\n      let is2 = compileAExp(e2) in\n        let is3 = compileAExp(e3) in\n          concat(is1, Cons(Branch(is2, is3), Nil))\n  \n\nfun compileBExp(e) = if e is\n  True then Cons(Push(1), Nil)\n  False then Cons(Push(0), Nil)\n  Not(e) then concat(compileBExp(e), Cons(Neg, Nil))\n  Conj(e1, e2) then\n    let is1 = compileBExp(e1) in\n      let is2 = compileBExp(e2) in\n        concat(concat(is2, is1), Cons(And, Nil))\n  Disj(e1, e2) then\n    let is1 = compileBExp(e1) in\n      let is2 = compileBExp(e2) in\n        concat(concat(is2, is1), Cons(Or, Nil))\n  Eq(e1, e2) then\n    let is1 = compileAExp(e1) in\n      let is2 = compileAExp(e2) in\n        concat(concat(is2, is1), Cons(Cmp, Nil))\n  Neq(e1, e2) then\n    let is1 = compileAExp(e1) in\n      let is2 = compileAExp(e2) in\n        concat(concat(is2, is1), Cons(Neg, Cons(Cmp, Nil)))\n\n\n// * Examples\n\ncompileAExp(Cst(42))\ncompileAExp(Plus(Cst(42), Cst(21)))\ncompileAExp(Minus(Cst(42), Cst(21)))\ncompileAExp(IfThenElse(True, Cst(1), Cst(2)))\ncompileAExp(IfThenElse(Neq(Cst(1), Cst(2)), Cst(42), Cst(21)))\ncompileBExp(True)\ncompileBExp(Not(True))\ncompileBExp(Conj(True, False))\ncompileBExp(Disj(True, False))\ncompileBExp(Neq(Cst(1), Cst(2)))\n\n\n// So far, we have not supported nested patterns.\n// This helper function is for the following pattern matching:\n// `if lst is Cons(x, Cons(y, ys)) then f(x, y, ys) else g()`\nfun matchTwo(lst, f, g) = if lst is\n  Nil then g()\n  Cons(x, xs) then\n    if xs is\n      Nil then g()\n      Cons(y, ys) then f(x, y, ys)\n\n\n// * Instruction evaluation\n\nfun evalInst(insts, stack) = if insts is\n  Nil then\n    if stack is\n      Cons(x, xs) then\n        if xs is\n          Nil then x\n          Cons(_, _) then error\n      Nil then error\n  Cons(inst, rest) then if inst is\n    Push(i) then evalInst(rest, Cons(i, stack))\n    Add then matchTwo(stack, (x, y, r) => evalInst(rest, Cons(x + y, r)), () => error)\n    Sub then matchTwo(stack, (x, y, r) => evalInst(rest, Cons(x - y, r)), () => error)\n    Mul then matchTwo(stack, (x, y, r) => evalInst(rest, Cons(x * y, r)), () => error)\n    Neg then if stack is\n      Nil then error\n      Cons(x, xs) then evalInst(rest, Cons(if x == 0 then 1 else 0, xs))\n    And then\n      matchTwo(stack, (x, y, r) => evalInst(rest, Cons(if x != 0 && y != 0 then 1 else 0, r)), () => error)\n    Or then\n      matchTwo(stack, (x, y, r) => evalInst(rest, Cons(if x != 0 || y != 0 then 1 else 0, r)), () => error)\n    Cmp then\n      matchTwo(stack, (x, y, r) => evalInst(rest, Cons(if x == y then 1 else 0, r)), () => error)\n    Branch(is1, is2) then if stack is\n      Nil then error\n      Cons(x, xs) then\n        if x != 0 then evalInst(is1, xs)\n        else evalInst(is2, xs)\n\n\n// * Examples\n\nevalInst(compileAExp(Cst(42)), Nil)\nevalInst(compileAExp(Plus(Cst(42), Cst(21))), Nil)\nevalInst(compileAExp(Minus(Cst(42), Cst(21))), Nil)\nevalInst(compileAExp(IfThenElse(True, Cst(1), Cst(2))), Nil)\nevalInst(compileAExp(IfThenElse(Neq(Cst(1), Cst(2)), Cst(42), Cst(21))), Nil)\nevalInst(compileAExp(IfThenElse(Eq(Cst(1), Cst(2)), Cst(42), Times(Cst(21), Cst(82)))), Nil)\n"
    });
    tmp11 = Predef.pipeInto(Examples.examples, tmp10);
    tmp12 = MutMap.insert("Exception.mls", {
    "name": "Exception", "source": "\n// * This files includes the exception handling extension of InvalML.\n\nclass Exc[T, R]\n\nfun (;) seq(_, res) = res\n\nfun raise: [T, P] -> (Exc[T, P], T) ->{P} Nothing\nfun hdle: [Res, E, T] -> ([P] -> (Exc[T, P]) ->{E | P} Res, T ->{E} Res) ->{E} Res\nfun print: Str -> Unit\n\n\nhdle(e => raise(e, \"oops!\"), msg => print(msg))\n\n// Error! The payload type is incorrect.\n// hdle(e => raise(e, 42), msg => print(msg))\n\n\nfun div(x, y) =\n  hdle(e => if y is 0 then raise(e, \"div-by-zero!\") else x / y, msg => print(msg); 0)\n\n\nhdle(e1 => hdle(e2 => raise(e1, \"oops!\"), msg => print(msg)), msg => print(msg))\nhdle(e1 => hdle(e2 => raise(e2, \"oops!\"), msg => print(msg)), msg => print(msg))\nhdle(e1 => hdle(e2 => raise(e1, \"oops!\"), msg => raise(e1, msg)), msg => print(msg))\n\n\n// Error! The exception handler cannot be leaked.\n// let h = hdle(e => e, msg => print(msg))\n// raise(h, \"leaked!\")\n"
    });
    tmp13 = Predef.pipeInto(Examples.examples, tmp12);
    tmp14 = MutMap.insert("StackMM.mls", {
    "name": "Stack-Based Memory Management", "source": "\n// * This files includes the stack-based memory management extension of InvalML.\n\nclass Stack[R]\nclass StackRef[T, R]\n\nfun (;) seq(_, res) = res\n\nfun allocStack: [R] -> Region[R] ->{R} Stack[R]\nfun alloc: [T, R] -> (Stack[R], T) ->{R} StackRef[T, R]\nfun read: [T, R] -> StackRef[T, R] ->{R} T\nfun write: [T, R] -> (StackRef[T, R], T) ->{R} ()\nfun push: [Res, R, E extends ~R] -> (Stack[R], [R'] -> Stack[R'] -> {R' | E} Res) ->{E | R} Res\n\n\nregion r in\n  let s1 = allocStack(r)\n  let r1 = alloc(s1, 42)\n  let r2 = alloc(s1, 0)\n  write(r1, 1)\n  read(r2)\n\n\nregion r in\n  let s1 = allocStack(r)\n  let r1 = alloc(s1, 42)\n  let r2 = alloc(s1, 0)\n  write(r1, 1)\n  read(r2)\n  push(s1, s2 => let r3 = alloc(s2, 0) in read(r3))\n\n\n// Error! After pusing `s1`, one can not access `s1`.\n// region r in\n//   let s1 = allocStack(r)\n//   let r1 = alloc(s1, 42)\n//   let r2 = alloc(s1, 0)\n//   write(r1, 1)\n//   read(r2)\n//   push(s1, s2 => let r3 = alloc(s2, 0) in read(r3) + read(r2))\n"
    });
    tmp15 = Predef.pipeInto(Examples.examples, tmp14);
    tmp16 = MutMap.insert("Staging.mls", {
    "name": "Scope-Safe Metaprogramming", "source": "\n// * This files includes the metaprogramming extension of InvalML.\n\n// Type `CodeBase[T, R, S]`:\n//   T: type of quoted expression\n//   R: union of free variables' skolems\n//   S: can be either top or bot. `CodeBase[T, R, bot]` is equivalent to `Var[T, R]`; `CodeBase[T, R, top]` is equivalent to `Code[T, R]`.\n\nfun power: [C] -> CodeBase[out Num, out C, out Any] -> Int -> CodeBase[out Num, out C, out Any]\nfun power(x) = case\n  0 then `1.0\n  n then x `*. power(x)(n - 1)\npower\n\nfun id: [A] -> A -> A\nfun id(x) = x\n\n\nrun(x `=> id(x) `* x)\n\n\nfun assertNotZero: [C] -> CodeBase[out Num, out C, out Any] -> CodeBase[out Num, out C, out Any]\nfun assertNotZero(x) =\n  `if (x `== `0.0) then `error else x\nlet checkedDiv = x `=> y `=> x `/. (assertNotZero(y))\nrun(checkedDiv)\n\n\n\nfun show: [T] -> CodeBase[out T, out Any, out Any] -> Str = s => \"debug\"\n\nfun inc(dbg) =\n  x `=> let c = x `+ `1 in let t = dbg(c) in c\n\ninc(c => log(show(c)))\n\nfun body_naive: [T, C] -> (CodeBase[out Int, out T, out Any], CodeBase[out Int, out C, out Any]) -> Int -> CodeBase[out Int, out T | C, out Any]\nfun body_naive(x, y) = case\n  0 then x\n  1 then y\n  n then body_naive(y, x `+ y)(n - 1)\nfun gib_naive(n) =\n  (x, y) `=> body_naive(x, y)(n)\nlet gn5 = run(gib_naive(5))\n\n\n// Wrong version! There is an unexpected extrusion in `bind`, making `bind` unusable.\n// fun bind(rhs, k) = `let x = rhs `in k(x)\n// fun body: [G] -> (CodeBase[out Int, out G, out Any], CodeBase[out Int, out G, out Any]) -> Int -> CodeBase[out Int, out G, out Any]\n// fun body(x, y) = case\n//   0 then x\n//   1 then y\n//   n then bind of x `+ y, (z => body(y, z)(n - 1))\n\n\nfun bind: [G] -> (CodeBase[out Int, out G, out Any], [C] -> CodeBase[out Int, out C, out Any] -> CodeBase[out Int, out C | G, out Any]) -> CodeBase[out Int, out G, out Any]\nfun bind(rhs, k) = `let x = rhs `in k(x)\n\nfun body: [G] -> (CodeBase[out Int, out G, out Any], CodeBase[out Int, out G, out Any]) -> Int -> CodeBase[out Int, out G, out Any]\nfun body(x, y) = case\n  0 then x\n  1 then y\n  n then bind of x `+ y, (z => body(y, z)(n - 1))\n\nfun gib(n) = (x, y) `=> body(x, y)(n)\nlet g5 = run(gib(5))\ng5\n"
    });
    tmp17 = Predef.pipeInto(Examples.examples, tmp16);
    tmp18 = MutMap.insert("DynamicProgramming.mls", {
    "name": "Dynamic Programming", "source": "\n// * In this file, we implement a select function to select some interviewees from the candidate list within a limited budget,\n// * such that the sum of the selected interviewees' estimation scores is highest,\n// * which is a classical Knapsack problem.\n\n// *** infrastructures\n\nclass Option[A] with\n  constructor\n    Some(x: A)\n    None\n\n\nclass ArrayList[T, out R]\nclass Iter[T, out R]\nclass Array2D[T, out R]\n\nclass Interviewee with\n  constructor\n    Itv(score: Int, salary: Int)\n\nfun (;) seq(_, res) = res\nfun toString: Any -> Str\nfun concat: (Str, Str) -> Str\nfun println: Str -> ()\n\nfun\n  empty:   [A, R] -> Region[out R] ->{R} ArrayList[A, out R]\n  push:    [A, R] -> (ArrayList[A, out R], A) ->{R} ()\n  iter: [Res, R, E extends ~R, T] ->\n    (ArrayList[T, out R], [S] -> Iter[T, S] ->{S | E} Res) ->{E | R} Res\n  revIter: [outer, Res, R, E extends ~R, T] ->\n    (ArrayList[T, out R], [S extends ~outer] -> Iter[T, S] ->{S | E} Res) ->{E | R} Res\n  next: [T, S] -> Iter[T, S] ->{S} Option[T]\n  len:  [A, R] -> (ArrayList[A, out R]) ->{R} Int\n  whileDo: [R] -> (() ->{R} Bool) ->{R} ()\n  init:    [A, R] -> (Region[out R], Int, Int, A) ->{R} Array2D[A, R]\n  update: [A, R] -> (Array2D[A, out R], Int, Int, A) ->{R} ()\n  get: [A, R] -> (Array2D[A, out R], Int, Int) ->{R} A\n  max: (Int, Int) -> Int\n\n\n// *** implementation\n\nfun format(it) =\n  if it is Itv(score, salary) then\n    concat(\"interviewee, score: \", concat(toString(score), concat(\"salary\", toString(salary))))\n\n\nfun printAll(arr) =\n  iter of arr, it =>\n    whileDo of () =>\n      if next(it) is\n        Some(x) then println(format(x)); true\n        None then false\n\n\n// fun select: [outer, R1 extends outer, R2 extends ~R1] -> (ArrayList[Interviewee, R1], Int, ArrayList[Interviewee, R2]) ->{R1 | R2} Int\nfun select(interviewees, budget, results) =\n  region r in\n    let size = len(interviewees), let i = r.ref 1\n    let dp = init(r, size + 1, budget + 1, 0)\n    iter of interviewees, it => whileDo of () =>\n      if next(it) is\n        Some(itv) then if itv is Itv(score, salary) then\n          let j = r.ref 0\n          whileDo of () =>\n            if !j < salary then update(dp, !i, !j, get(dp, !i - 1, !j))\n            else\n              let p = get(dp, !i - 1, !j - salary), let np = get(dp, !i - 1, !j)\n              update(dp, !i, !j, max of np, p + score)\n            j := !j + 1; !j <= budget\n          i := !i + 1\n          true\n        None then false\n    i := size\n    let rest = r.ref budget\n    revIter of interviewees, it =>\n      whileDo of () =>\n        if next(it) is\n          Some(itv) then if itv is Itv(score, salary) then\n            if get(dp, !i, !rest) == get(dp, !i - 1, !rest - salary) + score\n                do push(results, itv); rest := !rest - salary\n            i := !i - 1\n            true\n          None then false\n    get(dp, size, budget)\n\n// *** wrong version\n// fun wrongSelect(interviewees, budget, results) =\n//   region r in\n//     let size = len(interviewees), let i = r.ref 1\n//     let dp = init(r, size + 1, budget + 1, 0)\n//     iter of interviewees, it =>\n//       whileDo of () =>\n//         if next(it) is\n//           Some(itv) then if itv is Itv(score, salary) then\n//             let j = r.ref 0\n//             whileDo of () =>\n//               if !j < salary then update(dp, !i, !j, get(dp, !i - 1, !j))\n//               else\n//                 let p = get(dp, !i - 1, !j - salary), let np = get(dp, !i - 1, !j)\n//                 update(dp, !i, !j, max of np, p + score)\n//               j := !j + 1; !j <= budget\n//             i := !i + 1\n//             true\n//           None then false\n//     i := size\n//     let rest = r.ref budget\n//     revIter of interviewees, it =>\n//       whileDo of () =>\n//         if next(it) is\n//           Some(itv) then if itv is Itv(score, salary) then\n//             if get(dp, !i, !rest) == get(dp, !i - 1, !rest - salary) + score\n//                 do push(interviewees, itv); rest := !rest - salary\n//             i := !i - 1\n//             true\n//           None then false\n//     get(dp, size, budget)\n\n// region r in\n//   let interviewees = empty(r)\n//   push(interviewees, Itv(20, 3000))\n//   push(interviewees, Itv(50, 1000))\n//   push(interviewees, Itv(30, 1000))\n//   region r2 in\n//     let results = empty(r2)\n//     let m = wrongSelect(interviewees, 4000, results)\n//     printAll(results)\n//     m\n\n// *** example\nregion r in\n  let interviewees = empty(r)\n  push(interviewees, Itv(40, 10))\n  push(interviewees, Itv(60, 20))\n  push(interviewees, Itv(120, 30))\n  push(interviewees, Itv(70, 20))\n  println(\"all interviewees:\")\n  printAll(interviewees)\n  region r2 in\n    let results = empty(r2)\n    let m = select(interviewees, 60, results)\n    println(\"candidates:\")\n    printAll(results)\n    m\n"
    });
    Predef.pipeInto(Examples.examples, tmp18)
  }
  static toString() { return "Examples"; }
});
let Examples = Examples1; export default Examples;
